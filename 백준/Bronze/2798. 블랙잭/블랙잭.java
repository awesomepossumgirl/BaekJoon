
import java.util.Scanner;

public class Main{
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		
		int N = sc.nextInt();
		int M = sc.nextInt();
		int[] card = new int[N];
		
		for(int i=0; i<N; i++) {
			card[i] = sc.nextInt();
		}
		
		int mini = 0;
		for(int i=0; i<=N-3; i++) {
			for(int j=i+1; j<=N-2; j++) {
				for(int k=j+1; k<N; k++) {
					int hap = card[i]+card[j]+card[k]; // 세 카드의 합과 M이 같다면 hap을 출력하고 바로 종료
					if(hap==M) {
						System.out.println(hap);
						return;
					}
					if(mini<hap&&hap<M) {
						mini=hap;
						// hap이 이전 합보다 크고 M보다 작다면 (M에 더 가까운것임)
    						// mini에 hap 저장
					}
				}
			}
		}
		System.out.println(mini);

		/*
		
		이 코드는 주어진 카드에서 세 장을 선택하여 그 합이 딜러가 외친 숫자 M과 가장 가까운 값을 찾는 문제를 해결하는 것으로 보입니다.
		
		이런 유형의 문제에서 i 반복문이 N-3까지인 이유는, 세 장을 선택하는데 첫 번째 카드부터 세 번째 카드까지 선택하는 경우를 나타내기 위함입니다.
		
		구체적으로 설명하면:
		
		i 반복문은 첫 번째 카드를 선택하는 루프입니다.
		j 반복문은 두 번째 카드를 선택하는 루프이며, i 다음 인덱스부터 시작하여 중복을 피합니다.
		k 반복문은 세 번째 카드를 선택하는 루프이며, j 다음 인덱스부터 시작하여 중복을 피합니다.
		이렇게 하면 중복 없이 가능한 모든 세 장의 카드 조합을 확인할 수 있습니다. 만약 i의 범위가 N-2까지라면 중복된 조합이 발생할 수 있습니다.
		
		따라서 i 반복문의 범위가 N-3까지로 설정된 것은 중복을 피하고 모든 가능한 세 카드 조합을 확인하기 위함입니다.

  		
		j 반복문이 N-2까지인 이유는, 각 i에 대해 두 번째로 선택되는 카드의 인덱스를 나타내기 때문입니다. 코드에서 i는 첫 번째로 선택되는 카드의 인덱스이며, j는 두 번째로 선택되는 카드의 인덱스입니다.
		
		구체적으로 설명하면:
		
		i 반복문은 첫 번째 카드를 선택하는 루프입니다.
		j 반복문은 두 번째 카드를 선택하는 루프이며, i 다음 인덱스부터 시작하여 중복을 피합니다.
		k 반복문은 세 번째 카드를 선택하는 루프이며, j 다음 인덱스부터 시작하여 중복을 피합니다.
		따라서 j의 범위가 i+1부터 시작하여 N-2까지인 것은, 중복된 조합을 피하고 모든 가능한 세 카드 조합을 확인하기 위함입니다. j가 i+1부터 시작하므로 첫 번째로 선택된 카드 다음부터 시작하게 되고, N-2까지인 이유는 두 번째로 선택되는 카드의 최대 인덱스가 N-1이기 때문입니다.
		  		
  		*/
	}
}
